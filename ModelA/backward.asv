function [p1, p2, q1, q2] = backward(x1, x2, u1, u2, xi1, xi2, dt, N, M, params)
% backward - Backward BSDE solver for Model A using regression (Algorithm 1)
%
% Inputs:
%   x1, x2   : [N+1 x M] state trajectories
%   u1, u2   : [N x M] controls
%   xi1, xi2 : [N x M] Brownian increments
%   dt       : timestep
%   N        : number of time steps
%   M        : number of sample paths
%   params   : struct with parameters (alpha, beta, gamma, delta, sigma1, sigma2, gamma1, gamma2, epsilon)
%
% Outputs:
%   p1, p2   : [N+1 x M] adjoint processes
%   q1, q2   : [N x M] estimated q-processes

    % Extract model parameters
    alpha  = params.alpha;
    beta   = params.beta;
    gamma  = params.gamma;
    delta  = params.delta;
    sigma1 = params.sigma1;
    sigma2 = params.sigma2;
    gamma1 = params.gamma1;
    gamma2 = params.gamma2;
    epsilon = params.epsilon;

    % Initialize arrays
    p1 = zeros(N+1, M);
    p2 = zeros(N+1, M);
    q1 = zeros(N, M);
    q2 = zeros(N, M);

    % Terminal conditions: p(T) = 0
    p1(N+1, :) = 0;
    p2(N+1, :) = 0;

    % Damping parameter
    damping = 1e-3;

    % Time stepping backward
    for i = N:-1:1
        % Drift update
        f1 = -(alpha - beta * x2(i,:)) .* p1(i+1,:) ...
            - delta * x2(i,:) .* p2(i+1,:) ...
            - sigma1 * q1(i,:) ...
            - gamma1 * (u1(i,:).^2) ./ max(x1(i,:).^2, epsilon);

        f2 = beta * x1(i,:) .* p1(i+1,:) ...
            - (-gamma + delta * x1(i,:)) .* p2(i+1,:) ...
            + sigma2 * q2(i,:) ...
            - gamma2 * (u2(i,:).^2) ./ max(x2(i,:).^2, epsilon);

        % Euler update with noise and damping (p(t_{i-1}) from p(t_i))
        p1(i,:) = p1(i+1,:) + f1 * dt + q1(i,:) .* sqrt(dt) .* xi1(i,:) %+ damping * p1(i+1,:);
        p2(i,:) = p2(i+1,:) + f2 * dt + q2(i,:) .* sqrt(dt) .* xi2(i,:) + damping * p2(i+1,:);

        % --- Build regression matrix ---
        phi = @(t, x1, x2) [ones(size(x1)), x1, x2]; % Simplified basis
        
        % Evaluate basis for all paths at current time t_i
        Phi = phi(i*dt, x1(i,:)', x2(i,:)');  % M x 3
        
        % Compute regression targets: y_j = p_j(t_{i-1}, m) * xi_j,i^(m)
        Y1 = p1(i,:)' .* xi1(i,:)';  % M x 1
        Y2 = p2(i,:)' .* xi2(i,:)';  % M x 1
        
        % Normalize targets to prevent near-zero values
        Y1_norm = max(1e-6, norm(Y1));
        Y2_norm = max(1e-6, norm(Y2));
        Y1 = Y1 / Y1_norm;
        Y2 = Y2 / Y2_norm;
        
        % Ridge regression
        lambda = 1e-3;  
        beta1 = (Phi' * Phi + lambda * eye(size(Phi,2))) \ (Phi' * Y1);
        beta2 = (Phi' * Phi + lambda * eye(size(Phi,2))) \ (Phi' * Y2);
        
        % Compute q_j with scaling
        q1(i,:) = (Phi * beta1)' * Y1_norm / sqrt(dt);
        q2(i,:) = (Phi * beta2)' * Y2_norm / sqrt(dt);
    end
end